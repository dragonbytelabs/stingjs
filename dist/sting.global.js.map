{
  "version": 3,
  "sources": ["../sting/entry/entry-global.js", "../sting/core/index.js", "../sting/core/utils.js", "../sting/core/reactivity.js", "../sting/core/store.js", "../sting/core/registry.js", "../sting/core/directives.js", "../sting/core/lifecycle.js", "../sting/core/runtime.js", "../sting/entry/shared.js", "../sting/directives/x-text.js", "../sting/directives/x-show.js", "../sting/directives/x-on.js", "../sting/directives/x-debug.js", "../sting/directives/x-model.js", "../sting/directives/x-bind.js", "../sting/directives/x-if.js", "../sting/directives/x-for.js", "../sting/directives/x-effect.js"],
  "sourcesContent": ["import { makeSting } from \"./shared.js\"\n\nimport \"../directives/x-text.js\"\nimport \"../directives/x-show.js\"\nimport \"../directives/x-on.js\"\nimport \"../directives/x-debug.js\"\nimport \"../directives/x-model.js\"\nimport \"../directives/x-bind.js\"\nimport \"../directives/x-if.js\"\nimport \"../directives/x-for.js\"\nimport \"../directives/x-effect.js\"\n\nconst stingInstance = makeSting()\n\nexport default stingInstance\n", "export { signal, effect, batch, untrack, computed, STING_SIGNAL } from \"./reactivity.js\"\nexport { store, produce } from \"./store.js\"\nexport { data } from \"./registry.js\"\nexport { start, startSubtree, mountComponent } from \"./runtime.js\"\nexport { directive, use, binders } from \"./directives.js\"\nexport { onCleanup, setIntervalSafe, setTimeoutSafe } from \"./lifecycle.js\"\nexport * from \"./utils.js\"\n", "import { STING_SIGNAL } from \"./reactivity.js\"\n\n/**\n * @typedef {Error & { code?: string }} StingError\n */\n\n/**\n * True if we should run dev-only checks/logs.\n * @type {boolean}\n */\nexport const __DEV__ = typeof __DEV__ !== \"undefined\" ? __DEV__ : true\n\n/**\n * Assert an invariant \n * If this fails, StingJS is in a state it doesn't know how to recover from.\n *\n * @param {any} condition\n * @param {string} message\n * @param {{ code?: string, cause?: any }=} options\n * @returns {asserts condition}\n */\nexport function assert(condition, message, options) {\n  if (condition) return\n  const err = /** @type {StingError} */ (new Error(message))\n  if (options?.code) err.code = options.code\n  if (options?.cause) err.cause = options.cause\n  throw err\n}\n\n/**\n * Dev-only assert. \n *\n * @param {any} condition\n * @param {string} message\n * @returns {asserts condition}\n */\nexport function devAssert(condition, message) {\n  if (!__DEV__) return\n  assert(condition, message)\n}\n\n/**\n * Dev-only warning (user misuse, not engine corruption).\n *\n * @param {string} message\n * @param {any=} extra\n */\nexport function devWarn(message, extra) {\n  if (!__DEV__) return\n  if (extra !== undefined) console.warn(message, extra)\n  else console.warn(message)\n}\n\n/**\n * Helper: safer string tag name for elements.\n * @param {Element} el\n */\nexport function elementTag(element) {\n  return element?.tagName?.toLowerCase?.() ?? \"\"\n}\n\n/**\n * Check if a path string is safe to eval.\n * Only allows simple dot-separated identifiers.\n *\n * @param {string} path\n * @returns {boolean}\n */\nexport function isPathSafe(path) {\n  if (typeof path !== \"string\") return false\n  return /^[A-Za-z_$][\\w$]*(\\.[A-Za-z_$][\\w$]*)*$/.test(path)\n}\n\n/**\n * Unwrap a signal getter (marked with STING_SIGNAL) or return the value as-is.\n *\n * @template T\n * @param {T | (() => T)} signal\n * @returns {T}\n */\nexport function unwrap(v) {\n  if (typeof v === \"function\" && v[STING_SIGNAL]) return v()\n  return v\n}", "import { devAssert } from \"./utils.js\"\n\n/**\n * A reactive computation runner that can be subscribed to signals.\n * It also tracks which signal observer-sets it is currently subscribed to.\n *\n * @typedef {(() => void) & { deps: Set<Set<Runner>> }} Runner\n */\n\n/**\n * Symbol used to mark Sting signal getter functions.\n * This lets unwrap() distinguish signals from normal functions (like event handlers).\n */\nexport const STING_SIGNAL = Symbol.for(\"sting.signal\")\n\n/**\n * Global pointer to the currently running reactive computation (effect).\n *\n * @type {null | Runner}\n */\nlet Listener = null\n\n/**\n * When batching, signal writes queue effects here instead of running immediately.\n * @type {null | Set<Runner>}\n */\nlet BatchQueue = null\n\nexport function batch(fn) {\n  const prev = BatchQueue\n  const queue = new Set()\n  BatchQueue = queue\n  try {\n    return fn()\n  } finally {\n    BatchQueue = prev\n\n    if (!prev) {\n      for (const runner of queue) runner()\n    } else {\n      for (const runner of queue) prev.add(runner)\n    }\n  }\n}\n\n/**\n * Create a reactive signal (a single reactive value).\n *\n * @template T\n * @param {T} initial\n * @returns {[() => T, (next: T | ((prev: T) => T)) => T]}\n */\nexport function signal(initial) {\n  let value = initial\n  /** @type {Set<Runner>} */\n  const observers = new Set()\n\n  function read() {\n    if (Listener) {\n      observers.add(Listener)\n      Listener.deps.add(observers)\n    }\n    return value\n  }\n\n  // MARK THIS FUNCTION AS A SIGNAL GETTER\n  read[STING_SIGNAL] = true\n\n  function write(next) {\n    devAssert(observers instanceof Set, \"[sting] signal observers must be a Set\")\n\n    const nextValue = typeof next === \"function\" ? next(value) : next\n    if (Object.is(nextValue, value)) return value\n\n    value = nextValue\n    if (BatchQueue) {\n      for (const fn of observers) BatchQueue.add(fn)\n    } else {\n      const toRun = Array.from(observers)\n      for (const fn of toRun) fn()\n    }\n    return value\n  }\n\n  read._debugObservers = observers\n  return [read, write]\n}\n\n/**\n * Create a reactive effect: a computation that re-runs whenever its dependencies change.\n *\n * @param {() => void} fn\n * @returns {() => void} dispose function\n */\nexport function effect(fn) {\n  let disposed = false\n\n  /** @type {null | (() => void)} */\n  let cleanup = null\n\n  /** @type {Runner} */\n  const runner = /** @type {any} */ (function run() {\n    if (disposed) return\n\n    if (cleanup) {\n      try {\n        cleanup()\n      } catch (e) {\n        console.error(\"[sting] effect cleanup error:\", e)\n      }\n    }\n\n    for (const depObservers of runner.deps) {\n      depObservers.delete(runner)\n    }\n    runner.deps.clear()\n\n    const prev = Listener\n    Listener = runner\n    try {\n      const ret = fn()\n      if (typeof ret === \"function\") cleanup = ret\n    } finally {\n      Listener = prev\n    }\n  })\n\n  runner.deps = new Set()\n  runner()\n\n  return function dispose() {\n    if (disposed) return\n    disposed = true\n\n    if (cleanup) {\n      try {\n        cleanup()\n      } catch (e) {\n        console.error(\"[sting] effect cleanup error:\", e)\n      }\n    }\n\n    for (const depObservers of runner.deps) {\n      depObservers.delete(runner)\n    }\n    runner.deps.clear()\n  }\n}\n\n/**\n * Create a derived signal whose value is computed from other signals.\n *\n * @template T\n * @param {() => T} fn\n * @returns {() => T}\n */\nexport function computed(fn) {\n  const [get, set] = signal(undefined)\n\n  const dispose = effect(() => {\n    set(fn())\n  })\n\n  get.dispose = dispose\n  return get\n}\n\n/**\n * \n * Runs the given function without tracking any signal reads.\n * \n * @param {() => void} fn\n * @returns {() => void} fn \n * \n */\nexport function untrack(fn) {\n  const prev = Listener\n  Listener = null\n  try {\n    return fn()\n  } finally {\n    Listener = prev\n  }\n}\n", "import { signal } from \"./reactivity.js\"\n\n/**\n * Produce helper: mutate draft, return next.\n */\nexport function produce(mutator) {\n    return (prev) => {\n        const draft =\n            typeof structuredClone === \"function\"\n                ? structuredClone(prev)\n                : JSON.parse(JSON.stringify(prev))\n\n        mutator(draft)\n        return draft\n    }\n}\n\n/**\n * Deep proxy store:\n * - reading any property tracks the whole store signal\n * - writing any nested property triggers a root update via produce + path\n */\nexport function store(initial) {\n    const [get, set] = signal(initial)\n\n    /** cache proxies per (rootObjIdentity, pathKey) */\n    const proxyCache = new WeakMap()\n\n    function getAtPath(obj, path) {\n        let cur = obj\n        for (const key of path) cur = cur?.[key]\n        return cur\n    }\n\n    function setAtPath(draft, path, value) {\n        if (path.length === 0) return\n        let cur = draft\n        for (let i = 0; i < path.length - 1; i++) {\n            const k = path[i]\n            const next = cur?.[k]\n            // create containers if missing\n            if (next == null || typeof next !== \"object\") {\n                // choose array vs object based on next key if numeric\n                const nk = path[i + 1]\n                cur[k] = typeof nk === \"number\" ? [] : {}\n            }\n            cur = cur[k]\n        }\n        cur[path[path.length - 1]] = value\n    }\n\n    function delAtPath(draft, path) {\n        if (path.length === 0) return\n        let cur = draft\n        for (let i = 0; i < path.length - 1; i++) {\n            cur = cur?.[path[i]]\n            if (cur == null) return\n        }\n        delete cur[path[path.length - 1]]\n    }\n\n    function makeProxy(path) {\n        const raw = get()\n        if (raw == null || typeof raw !== \"object\") {\n            // if someone stores a primitive, just return it (rare)\n            return raw\n        }\n\n        // key cache by the *current root object identity* + path string\n        let perRoot = proxyCache.get(raw)\n        if (!perRoot) {\n            perRoot = new Map()\n            proxyCache.set(raw, perRoot)\n        }\n\n        const key = path.join(\".\")\n        if (perRoot.has(key)) return perRoot.get(key)\n\n        const p = new Proxy(\n            {},\n            {\n                get(_t, prop) {\n                    if (prop === Symbol.toStringTag) return \"StingStore\"\n                    if (prop === \"__raw\") return get()\n                    if (prop === \"__path\") return path.slice()\n\n                    const cur = getAtPath(get(), path)\n\n                    // allow symbols (like util.inspect) to pass through\n                    if (typeof prop === \"symbol\") return cur?.[prop]\n\n                    const value = cur?.[prop]\n\n                    // If it's an object/array, return a nested proxy\n                    if (value && typeof value === \"object\") {\n                        return makeProxy(path.concat(prop))\n                    }\n\n                    return value\n                },\n\n                set(_t, prop, value) {\n                    if (typeof prop === \"symbol\") return false\n\n                    set(\n                        produce((draft) => {\n                            setAtPath(draft, path.concat(prop), value)\n                        })\n                    )\n                    return true\n                },\n\n                deleteProperty(_t, prop) {\n                    if (typeof prop === \"symbol\") return false\n\n                    set(\n                        produce((draft) => {\n                            delAtPath(draft, path.concat(prop))\n                        })\n                    )\n                    return true\n                },\n\n                ownKeys() {\n                    const cur = getAtPath(get(), path)\n                    return Reflect.ownKeys(cur ?? {})\n                },\n\n                getOwnPropertyDescriptor(_t, prop) {\n                    const cur = getAtPath(get(), path)\n                    if (cur && prop in cur) return { enumerable: true, configurable: true }\n                },\n            }\n        )\n\n        perRoot.set(key, p)\n        return p\n    }\n\n    function setStore(next) {\n        set(next) // supports value OR updater function because signal.write handles it\n    }\n\n    return [makeProxy([]), setStore]\n}\n", "/** @type {Map<string, () => any>} */\nconst registry = new Map()\n\n/**\n * Register a component factory by name.\n * x-data=\"name\" will call this factory to create the component scope.\n *\n * @param {string} name\n * @param {() => any} factory\n */\nexport function data(name, factory) {\n    registry.set(name, factory)\n}\n\n/**\n * Get a component factory by name.\n * Internal use only.\n *\n * @param {string} name\n * @returns {(() => any) | undefined}\n */\nexport function getFactory(name) {\n    return registry.get(name)\n}\n", "/**\n * A directive binder function.\n *\n * @typedef {(ctx: import('./runtime.js').DirectiveContext) => void} DirectiveBinder\n */\n\n/** @type {DirectiveBinder[]} */\nexport const binders = []\n\n/** @type {Set<DirectiveBinder>} */\nconst binderSet = new Set()\n\n/**\n * Register a directive binder.\n * Idempotent: registering the same binder twice is a no-op.\n *\n * @param {DirectiveBinder} binder\n * @returns {() => void} unregister function\n */\nexport function directive(binder) {\n    if (!binderSet.has(binder)) {\n        binderSet.add(binder)\n        binders.push(binder)\n    }\n\n    // optional: allow unregistering (handy for tests/devtools)\n    return () => {\n        if (!binderSet.delete(binder)) return\n        const i = binders.indexOf(binder)\n        if (i >= 0) binders.splice(i, 1)\n    }\n}\n\n/**\n * Install a plugin.\n * A plugin is a function that receives the Sting API.\n *\n * @param {(sting: { directive: typeof directive }) => void} plugin\n */\nexport function use(plugin) {\n    plugin({ directive })\n}\n", "import { devAssert } from \"./utils.js\"\n\nlet CURRENT_DISPOSERS = null\n\nexport function _withDisposers(disposers, fn) {\n  const prev = CURRENT_DISPOSERS\n  CURRENT_DISPOSERS = disposers\n  try {\n    return fn()\n  } finally {\n    CURRENT_DISPOSERS = prev\n  }\n}\n\nexport function onCleanup(fn) {\n  devAssert(typeof fn === \"function\", \"[sting] onCleanup(fn) requires a function\")\n  devAssert(!!CURRENT_DISPOSERS, \"[sting] onCleanup() called outside component setup\")\n  CURRENT_DISPOSERS.push(fn)\n}\n\nexport function setIntervalSafe(ms, fn) {\n  const id = setInterval(fn, ms)\n  if (CURRENT_DISPOSERS) CURRENT_DISPOSERS.push(() => clearInterval(id))\n  return id\n}\n\nexport function setTimeoutSafe(ms, fn) {\n  const id = setTimeout(fn, ms)\n  if (CURRENT_DISPOSERS) CURRENT_DISPOSERS.push(() => clearTimeout(id))\n  return id\n}\n", "import { effect, untrack } from \"./reactivity.js\"\nimport { getFactory } from \"./registry.js\"\nimport { binders } from \"./directives.js\"\nimport { devAssert, devWarn } from \"./utils.js\"\nimport { _withDisposers } from \"./lifecycle.js\"\n\n/**\n * \n * @param {Elemebt} el \n * @param {string} name \n * @returns string | null\n */\nfunction getAttr(el, name) {\n  return el.getAttribute(name)\n}\n\n/**\n * Simple tree walker\n *\n * @param {Element} root\n * @param {(node: Element) => void} fn\n */\nfunction walk(root, fn) {\n  const stack = [root]\n  while (stack.length) {\n    const node = stack.pop()\n    if (!node) continue\n    fn(node)\n    for (let i = node.children.length - 1; i >= 0; i--) stack.push(node.children[i])\n  }\n}\n\n/**\n * Get a value from scope by dot-path\n *\n * @param {object} scope\n * @param {string} path\n * @returns {any}\n */\nfunction getPath(scope, path) {\n  const parts = path.split(\".\").map(s => s.trim()).filter(Boolean)\n  let cur = scope\n  for (const p of parts) cur = cur?.[p]\n  return cur\n}\n\n/**\n * Set a value in scope by dot-path\n *\n * @param {object} scope\n * @param {string} path\n * @param {any} value\n */\nfunction setPath(scope, path, value) {\n  const parts = path.split(\".\").map(s => s.trim()).filter(Boolean)\n  if (parts.length === 0) return\n  let cur = scope\n  for (let i = 0; i < parts.length - 1; i++) {\n    const key = parts[i]\n    cur = cur?.[key]\n    if (cur == null) {\n      console.warn(`setPath: \"${path}\" not reachable (missing \"${key}\")`)\n      return\n    }\n  }\n  cur[parts[parts.length - 1]] = value\n}\n\n/**\n * Apply all directives to a subtree\n *\n * @param {Element} rootEl\n * @param {object} scope\n * @param {Array<() => void>} disposers\n */\nexport function applyDirectives(rootEl, scope, disposers) {\n  const hydrate = (subtreeRootEl, subtreeScope, subtreeDisposers) => {\n    applyDirectives(subtreeRootEl, subtreeScope, subtreeDisposers)\n  }\n\n  walk(rootEl, (el) => {\n    const ctx = {\n      el,\n      scope,\n      getAttr,\n      getPath,\n      setPath,\n      effect,\n      untrack,\n      disposers,\n      hydrate,\n    }\n    for (const bind of binders) bind(ctx)\n  })\n}\n\n// --- mounting ---\nconst MOUNTED = new WeakSet()\n\n/**\n * Mount a component at the given root element.\n *\n * @param {Element} rootEl\n * @returns {(() => void) | undefined} disposer function\n */\nexport function mountComponent(rootEl) {\n  devAssert(rootEl instanceof Element, \"[sting] mountComponent expects an Element\")\n  if (MOUNTED.has(rootEl)) return\n\n  const name = getAttr(rootEl, \"x-data\")\n  devAssert(!!name, `[sting] mountComponent called without x-data`)\n\n  const factory = getFactory(name)\n  if (!factory) {\n    devWarn(\n      `[sting] component \"${name}\" not registered yet. ` +\n      `Did you call sting.data(\"${name}\", ...) before DOM ready?`,\n      rootEl\n    )\n    return\n  }\n\n  const disposers = []\n  const scope = _withDisposers(disposers, () => factory())\n\n  rootEl.__stingScope = scope\n  MOUNTED.add(rootEl)\n\n  applyDirectives(rootEl, scope, disposers)\n\n  return () => {\n    MOUNTED.delete(rootEl)\n    delete rootEl.__stingScope\n    for (let i = disposers.length - 1; i >= 0; i--) {\n      try { disposers[i]() } catch (e) { console.error(\"[sting] error during disposer\", e) }\n    }\n  }\n}\n\n/**\n * Start monitoring a subtree for components to mount.\n *\n * @param {Element} rootEl\n */\nexport function startSubtree(rootEl) {\n  devAssert(rootEl instanceof Element, \"[sting] startSubtree(rootEl) expects Element\")\n  // mount the root if it's x-data, and any nested x-data\n  if (rootEl.matches?.(\"[x-data]\")) mountComponent(rootEl)\n  rootEl.querySelectorAll?.(\"[x-data]\").forEach((el) => mountComponent(el))\n}\n\n/**\n * Start the Sting runtime on a root element (or document).\n *\n * @param {Document | Element} root\n * @returns {() => void} stop function\n */\nexport function start(root = document) {\n  devAssert(root === document || root instanceof Element, \"[sting] start(root) expects Document or Element\")\n\n  const base = root === document ? document.body : root\n  if (!base) return () => {}\n\n  // initial mount\n  startSubtree(base)\n\n  // unmount tracking\n  const destroys = new Map()\n  base.querySelectorAll?.(\"[x-data]\").forEach((el) => {\n    const d = mountComponent(el)\n    if (d) destroys.set(el, d)\n  })\n\n  const mo = new MutationObserver((mutations) => {\n    for (const m of mutations) {\n      for (const node of m.removedNodes) {\n        if (!(node instanceof Element)) continue\n\n        if (destroys.has(node)) {\n          destroys.get(node)()\n          destroys.delete(node)\n        }\n\n        node.querySelectorAll?.(\"[x-data]\").forEach((el) => {\n          if (destroys.has(el)) {\n            destroys.get(el)()\n            destroys.delete(el)\n          }\n        })\n      }\n\n      // if nodes are added, mount subtree\n      for (const node of m.addedNodes) {\n        if (!(node instanceof Element)) continue\n        startSubtree(node)\n      }\n    }\n  })\n\n  mo.observe(base, { childList: true, subtree: true })\n\n  return () => {\n    mo.disconnect()\n    for (const destroy of destroys.values()) destroy()\n    destroys.clear()\n  }\n}\n", "import * as core from \"../core/index.js\"\n\nexport function makeSting() {\n  let stop = null\n  let startQueued = false\n  let domReadyHooked = false\n\n  function startNow() {\n    if (stop) return stop\n    stop = core.start()\n    return stop\n  }\n\n  function ensureStarted() {\n    if (stop || startQueued) return\n    startQueued = true\n\n    queueMicrotask(() => {\n      startQueued = false\n      if (stop) return\n\n      // If DOM isn't ready yet, defer to DOMContentLoaded (same behavior as autoStart)\n      if (document.readyState === \"loading\") {\n        autoStart()\n        return\n      }\n\n      startNow()\n    })\n  }\n\n  function autoStart() {\n    if (stop || startQueued) return\n\n    if (document.readyState === \"loading\") {\n      if (domReadyHooked) return\n      domReadyHooked = true\n      document.addEventListener(\n        \"DOMContentLoaded\",\n        () => {\n          if (!stop) startNow()\n        },\n        { once: true }\n      )\n      return\n    }\n\n    startNow()\n  }\n\n  function data(name, factory) {\n    core.devAssert(typeof name === \"string\" && name.length > 0, `[sting] data(name) requires a string name`)\n    core.devAssert(typeof factory === \"function\", `[sting] data(\"${name}\") requires a factory function`)\n\n    core.data(name, factory)\n\n    // If runtime already started, mount any existing unmounted roots for this component.\n    if (stop) {\n      const selector = `[x-data=\"${cssEscape(name)}\"]`\n      document.querySelectorAll(selector).forEach((el) => {\n        if (!el.__stingScope) core.mountComponent(el)\n      })\n      return\n    }\n\n    // Otherwise, start (but only when DOM is ready)\n    ensureStarted()\n  }\n\n  return {\n    ...core,\n    data,\n    autoStart,\n    start: ensureStarted,\n    // optional: allow stopping in dev/tests\n    stop() {\n      if (!stop) return\n      stop()\n      stop = null\n    },\n  }\n}\n\n// Minimal CSS escape (good enough for your use; uses native if present)\nfunction cssEscape(s) {\n  if (typeof CSS !== \"undefined\" && CSS.escape) return CSS.escape(s)\n  return String(s).replace(/[\"\\\\]/g, \"\\\\$&\")\n}\n", "import { directive } from \"../core/directives.js\"\nimport { devAssert, devWarn, isPathSafe, unwrap } from \"../core/utils.js\"\n\n/**\n * x-text directive\n *\n * Sets the textContent of an element to the value of a scope path.\n *\n * Example:\n *   <div x-text=\"username\"></div>\n *\n * Constraints:\n * - The expression must be a safe dot-path (no eval).\n */\nexport function bindXText(ctx) {\n  const { el, scope, getAttr, getPath, effect, disposers } = ctx\n\n  const expr = getAttr(el, \"x-text\")\n  if (!expr) return\n\n  devAssert(isPathSafe(expr), `[sting] x-text invalid path \"${expr}\"`)\n\n  const dispose = effect(() => {\n    const raw = getPath(scope, expr)\n    let v = unwrap(raw)\n\n    // If value is a plain function (NOT a signal), treat it like a computed getter.\n    if (typeof v === \"function\") {\n      try {\n        v = v.length > 0 ? v(scope) : v()\n      } catch (e) {\n        devWarn(`[sting] x-text \"${expr}\" threw while evaluating`, e)\n        v = \"\"\n      }\n    }\n\n    el.textContent = v == null ? \"\" : String(v)\n  })\n\n  disposers.push(dispose)\n}\n\ndirective(bindXText)\n", "import { directive } from \"../core/directives.js\"\nimport { devAssert, isPathSafe, unwrap } from \"../core/utils.js\"\n\n/**\n * Bind the `x-show` directive.\n *\n * Toggles element visibility using `display: none` based on a reactive value.\n *\n * Example:\n *   <div x-show=\"open\"></div>\n *\n * Behavior:\n * - Truthy value \u2192 element is shown\n * - Falsy value \u2192 element is hidden (`display: none`)\n * - Preserves the element\u2019s original inline `display` style\n *\n * @param {import(\"../core/runtime.js\").DirectiveContext} ctx\n */\nexport function bindXShow(ctx) {\n  const { el, scope, getAttr, getPath, effect, disposers } = ctx\n\n  const expr = getAttr(el, \"x-show\")\n  if (!expr) return\n\n  devAssert(isPathSafe(expr), `[sting] x-show invalid path \"${expr}\"`)\n\n  const initialDisplay = el.style.display\n\n  const dispose = effect(() => {\n    const value = unwrap(getPath(scope, expr))\n    el.style.display = value ? initialDisplay : \"none\"\n  })\n\n  disposers.push(dispose)\n}\n\ndirective(bindXShow)", "import { directive } from \"../core/directives.js\"\nimport { devAssert, devWarn, isPathSafe, unwrap } from \"../core/utils.js\"\n\nexport function bindXOn(ctx) {\n  const { el, scope, getPath, disposers } = ctx\n\n  // bind all x-on:* on this element\n  for (const attr of el.attributes) {\n    if (!attr.name.startsWith(\"x-on:\")) continue\n\n    const eventName = attr.name.slice(\"x-on:\".length).trim()\n    const expr = (attr.value ?? \"\").trim()\n\n    if (!eventName) {\n      devWarn(`[sting] x-on missing event name`, el)\n      continue\n    }\n    if (!expr) {\n      devWarn(`[sting] x-on:${eventName} missing expression`, el)\n      continue\n    }\n\n    const parsed = parseOnExpr(expr)\n    devAssert(!!parsed, `[sting] x-on:${eventName} invalid expression \"${expr}\"`)\n\n    const handler = (ev) => {\n      const { fnPath, arg } = parsed\n\n      devAssert(isPathSafe(fnPath), `[sting] x-on:${eventName} invalid fn path \"${fnPath}\"`)\n\n      // IMPORTANT: resolve scope at click-time\n      const scopeNow = getClosestScope(el) || scope\n\n      // IMPORTANT: do NOT unwrap() handlers; unwrap() may execute functions\n      const maybeFn = getPath(scopeNow, fnPath)\n\n      devAssert(typeof maybeFn === \"function\", `[sting] x-on:${eventName} \"${fnPath}\" is not a function`)\n\n      // Call styles:\n      // - fn(event)\n      // - fn(arg, event)\n      if (arg == null) {\n        maybeFn(ev)\n        return\n      }\n\n      const argVal = resolveArg(scopeNow, getPath, arg)\n      maybeFn(argVal, ev)\n    }\n\n    el.addEventListener(eventName, handler)\n    disposers.push(() => el.removeEventListener(eventName, handler))\n  }\n}\n\ndirective(bindXOn)\n\nfunction getClosestScope(el) {\n  let cur = el\n  while (cur && cur !== document.body) {\n    if (cur.hasAttribute?.(\"x-data\") && cur.__stingScope) return cur.__stingScope\n    cur = cur.parentNode\n  }\n  return null\n}\n\n// Supports:\n//  - \"inc\"\n//  - \"remove(i)\"\n//  - \"obj.remove(i)\"\nfunction parseOnExpr(expr) {\n  const s = expr.trim()\n\n  // call form: fn(arg)\n  const m = s.match(/^([A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*)*)\\s*\\(\\s*(.*?)\\s*\\)\\s*$/)\n  if (m) {\n    const fnPath = m[1]\n    const rawArg = m[2]\n    const arg = rawArg === \"\" ? null : rawArg\n    return { fnPath, arg }\n  }\n\n  // plain path form: fn\n  if (isPathSafe(s)) return { fnPath: s, arg: null }\n\n  return null\n}\n\nfunction resolveArg(scope, getPath, argExpr) {\n  const s = String(argExpr).trim()\n\n  // string literal\n  if ((s.startsWith('\"') && s.endsWith('\"')) || (s.startsWith(\"'\") && s.endsWith(\"'\"))) {\n    return s.slice(1, -1)\n  }\n\n  // number literal\n  if (/^-?\\d+(?:\\.\\d+)?$/.test(s)) return Number(s)\n\n  // boolean/null/undefined\n  if (s === \"true\") return true\n  if (s === \"false\") return false\n  if (s === \"null\") return null\n  if (s === \"undefined\") return undefined\n\n  // identifier/path from scope (allow signals here)\n  devAssert(isPathSafe(s), `[sting] x-on arg must be a safe path or literal, got \"${s}\"`)\n  const v = getPath(scope, s)\n  return unwrap(v)\n}\n", "import { directive } from \"../core/directives.js\"\nimport { devAssert, isPathSafe } from \"../core/utils.js\"\n\n/**\n * Bind the `x-debug` directive.\n *\n * Renders live debug information about a signal directly into the DOM.\n * Intended for development only.\n *\n * Examples:\n *   <div x-debug=\"$open\"></div>\n *   <div x-debug=\"open\"></div> // will try `$open` automatically\n *\n * Behavior:\n * - Displays the current signal value\n * - Displays the number of subscribed observers\n * - Subscribes to the signal so the debug output stays live\n * - Uses `untrack()` when reading values to avoid feedback loops\n *\n * @param {import(\"../sting/sting.js\").DirectiveContext} ctx\n */\nexport function bindXDebug(ctx) {\n  const { el, scope, getAttr, getPath, effect, untrack, disposers } = ctx\n\n  const expr = getAttr(el, \"x-debug\")\n  if (!expr) return\n\n  devAssert(isPathSafe(expr), `[sting] x-debug invalid path \"${expr}\"`)\n\n  let sig = getPath(scope, expr)\n\n  // If the value facade was passed (e.g. \"open\"), try \"$open\"\n  if (typeof sig !== \"function\") {\n    sig = getPath(scope, `$${expr}`)\n  }\n\n  const dispose = effect(() => {\n    if (typeof sig !== \"function\") {\n      el.textContent = `debug(${expr}): not a signal getter`\n      return\n    }\n\n    // Subscribe so this effect reruns when the signal changes\n    sig()\n\n    // Read without tracking to avoid self-triggering loops\n    const value = untrack(() => sig())\n    const observers = sig._debugObservers?.size ?? \"?\"\n\n    el.textContent =\n      `debug(${expr}): value=${String(value)} observers=${observers}`\n  })\n\n  disposers.push(dispose)\n}\n\ndirective(bindXDebug)", "import { directive } from \"../core/directives.js\"\nimport { devWarn, elementTag, devAssert, isPathSafe } from \"../core/utils.js\"\n\n/**\n * Bind the `x-model` directive.\n *\n * Two-way bind between a form control's value and a scope path.\n *\n * - scope -> DOM: reactive effect updates el.value when the model changes\n * - DOM -> scope: input/change event updates the model via setPath\n * \n * Example:\n *   <input type=\"text\" x-model=\"message\">\n *   <span x-text=\"message\"></span>\n *\n * Supports: <input>, <textarea>, <select>\n * (checkbox/radio handled too)\n *\n * @param {import(\"../core/runtime.js\").DirectiveContext} ctx\n */\nexport function bindXModel(ctx) {\n    const { el, scope, getAttr, getPath, setPath, effect, disposers } = ctx\n\n    const expr = getAttr(el, \"x-model\")\n    if (!expr) return\n\n    devAssert(isPathSafe(expr), `[sting] x-model invalid path \"${expr}\"`)\n\n    const tag = elementTag(el)\n    const isInput = tag === \"input\"\n    const isTextarea = tag === \"textarea\"\n    const isSelect = tag === \"select\"\n\n    if (!isInput && !isTextarea && !isSelect) {\n        devWarn(`[sting] x-model can only be used on input/textarea/select`, el)\n        return\n    }\n\n    devAssert(typeof expr === \"string\" && expr.length > 0, \"[sting] x-model expr must be a non-empty string\")\n\n    /** @type {HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement} */\n    const field = /** @type {any} */ (el)\n\n    const inputType = isInput ? /** @type {HTMLInputElement} */ (field).type : \"\"\n    const isCheckbox = isInput && inputType === \"checkbox\"\n    const isRadio = isInput && inputType === \"radio\"\n\n    const onInput = () => {\n        if (isCheckbox) {\n            setPath(scope, expr, /** @type {HTMLInputElement} */(field).checked)\n            return\n        }\n\n        if (isRadio) {\n            const radio = /** @type {HTMLInputElement} */ (field)\n            if (radio.checked) setPath(scope, expr, radio.value)\n            return\n        }\n\n        setPath(scope, expr, field.value)\n    }\n\n    // use `input` for text-like controls, `change` for select/checkbox/radio\n    const eventName = (isSelect || isCheckbox || isRadio) ? \"change\" : \"input\"\n    field.addEventListener(eventName, onInput)\n    disposers.push(() => field.removeEventListener(eventName, onInput))\n\n    const dispose = effect(() => {\n        const value = getPath(scope, expr)\n\n        if (isCheckbox) {\n            const next = !!value\n            if (/** @type {HTMLInputElement} */ (field).checked !== next) {\n        /** @type {HTMLInputElement} */ (field).checked = next\n            }\n            return\n        }\n\n        // For radio groups, set checked when the value matches this radio's value\n        if (isRadio) {\n            const radio = /** @type {HTMLInputElement} */ (field)\n            const shouldCheck = String(value ?? \"\") === radio.value\n            if (radio.checked !== shouldCheck) radio.checked = shouldCheck\n            return\n        }\n\n        const next = value ?? \"\"\n        if (field.value !== String(next)) field.value = String(next)\n    })\n\n    disposers.push(dispose)\n}\n\ndirective(bindXModel)", "import { directive } from \"../core/directives.js\"\nimport { devAssert, devWarn, elementTag, isPathSafe, unwrap } from \"../core/utils.js\"\n\n/**\n * Bind `x-bind:*` attribute directives.\n *\n * Examples:\n *   <input x-bind:placeholder=\"placeholder\">\n *   <button x-bind:disabled=\"isBusy\">Save</button>\n *   <a x-bind:href=\"profileUrl\">Profile</a>\n *\n * Rules:\n * - expression must be a safe dot-path (no eval)\n * - unwrap() is applied so you can pass signals or plain values\n *\n * @param {import(\"../core/runtime.js\").DirectiveContext} ctx\n */\nexport function bindXBind(ctx) {\n    const { el, scope, getPath, effect, disposers } = ctx\n\n    // gather all x-bind:* on this element\n    for (const attr of el.attributes) {\n        if (!attr.name.startsWith(\"x-bind:\")) continue\n        const arg = attr.name.slice(\"x-bind:\".length).trim()\n        const expr = (attr.value ?? \"\").trim()\n        if (!arg) {\n            devWarn(`[sting] x-bind missing attribute name`, el)\n            continue\n        }\n        if (!expr) {\n            devWarn(`[sting] x-bind:${arg} is missing an expression`, el)\n            continue\n        }\n\n        devAssert(isPathSafe(expr), `[sting] x-bind:${arg} invalid path \"${expr}\"`)\n\n        const dispose = effect(() => {\n            const resolved = getPath(scope, expr)\n            let value = unwrap(resolved)\n\n            // Treat plain functions as computed getters for binding contexts\n            if (typeof value === \"function\") {\n                try {\n                    value = value.length > 0 ? value(scope) : value()\n                } catch (e) {\n                    devWarn(`[sting] x-bind:${arg} \"${expr}\" threw while evaluating`, e)\n                    value = null\n                }\n            }\n\n            applyBinding(el, arg, value)\n        })\n        disposers.push(dispose)\n    }\n\n}\n\ndirective(bindXBind)\n\n/**\n * Apply a binding to an element attribute/property.\n *\n * @param {Element} el\n * @param {string} attr\n * @param {any} value\n */\nfunction applyBinding(el, attr, value) {\n    const tag = elementTag(el)\n\n    // --- boolean-ish attributes ---\n    if (\n        attr === \"disabled\" ||\n        attr === \"checked\" ||\n        attr === \"selected\" ||\n        attr === \"readonly\" ||\n        attr === \"required\"\n    ) {\n        const next = !!value\n\n        // DOM property names:\n        const prop =\n            attr === \"readonly\" ? \"readOnly\" : attr\n\n        // @ts-ignore\n        if (prop in el) el[prop] = next\n\n        if (next) el.setAttribute(attr, \"\")\n        else el.removeAttribute(attr)\n\n        return\n    }\n\n    // --- value prop (inputs) ---\n    if (attr === \"value\" && (tag === \"input\" || tag === \"textarea\" || tag === \"select\")) {\n        const next = value ?? \"\"\n        // @ts-ignore\n        if (el.value !== String(next)) el.value = String(next)\n        return\n    }\n\n    if (attr === \"class\") {\n        applyClassBinding(el, value)\n        return\n    }\n\n    // --- style (string or object) ---\n    if (attr === \"style\") {\n        if (value && typeof value === \"object\") {\n            const parts = []\n            for (const [k, v] of Object.entries(value)) {\n                if (v == null || v === false) continue\n                parts.push(`${k}: ${String(v)};`)\n            }\n            el.setAttribute(\"style\", parts.join(\" \"))\n        } else {\n            el.setAttribute(\"style\", value ?? \"\")\n        }\n        return\n    }\n\n    // --- default: attribute ---\n    if (value == null || value === false) {\n        el.removeAttribute(attr)\n    } else {\n        el.setAttribute(attr, String(value))\n    }\n}\n\nconst CLASS_STATE = new WeakMap()\n\nfunction initClassState(el) {\n    let st = CLASS_STATE.get(el)\n    if (st) return st\n    st = {\n        base: new Set((el.getAttribute(\"class\") || \"\").split(/\\s+/).filter(Boolean)),\n        applied: new Set(),\n    }\n    CLASS_STATE.set(el, st)\n    return st\n}\n\nfunction normalizeClassValue(value) {\n    // supports: \"a b\", [\"a\",\"b\"], {a:true,b:false}\n    const out = new Set()\n\n    if (!value) return out\n\n    if (typeof value === \"string\") {\n        value.split(/\\s+/).filter(Boolean).forEach(c => out.add(c))\n        return out\n    }\n\n    if (Array.isArray(value)) {\n        for (const item of value) {\n            if (typeof item === \"string\") item.split(/\\s+/).filter(Boolean).forEach(c => out.add(c))\n        }\n        return out\n    }\n\n    if (typeof value === \"object\") {\n        for (const [cls, on] of Object.entries(value)) {\n            if (on) cls.split(/\\s+/).filter(Boolean).forEach(c => out.add(c))\n        }\n        return out\n    }\n\n    return out\n}\n\nfunction applyClassBinding(el, value) {\n    const st = initClassState(el)\n    const next = normalizeClassValue(value)\n\n    // remove previously applied bound classes\n    for (const c of st.applied) {\n        el.classList.remove(c)\n    }\n\n    // ensure base classes are present (in case something removed them)\n    for (const c of st.base) {\n        el.classList.add(c)\n    }\n\n    // add new bound classes\n    for (const c of next) {\n        el.classList.add(c)\n    }\n\n    st.applied = next\n}\n", "import { directive } from \"../core/directives.js\"\nimport { devAssert, isPathSafe, unwrap } from \"../core/utils.js\"\nimport { applyDirectives } from \"../core/runtime.js\" // <-- IMPORTANT\n\nconst IF_STATE = new WeakMap()\n\nexport function bindXIf(ctx) {\n  const { el, scope, getAttr, getPath, effect, disposers } = ctx\n\n  const expr = getAttr(el, \"x-if\")\n  if (!expr) return\n\n  devAssert(el.tagName.toLowerCase() === \"template\", `[sting] x-if can only be used on <template>`)\n  devAssert(isPathSafe(expr), `[sting] x-if invalid path \"${expr}\"`)\n\n  // state per template node\n  let st = IF_STATE.get(el)\n  if (!st) {\n    st = { mounted: false, nodes: /** @type {Node[]} */([]) }\n    IF_STATE.set(el, st)\n  }\n\n  const dispose = effect(() => {\n    const show = !!unwrap(getPath(scope, expr))\n\n    // mount\n    if (show && !st.mounted) {\n      // clone template content\n      const frag = document.importNode(el.content, true)\n\n      // capture inserted nodes (so we can remove them later)\n      st.nodes = Array.from(frag.childNodes)\n\n      // insert after the template\n      el.parentNode?.insertBefore(frag, el.nextSibling)\n\n      // hydrate directives in inserted elements\n      for (const n of st.nodes) {\n        if (n instanceof Element) applyDirectives(n, scope, disposers)\n        else if (n instanceof DocumentFragment) {\n          // unlikely here, but safe\n          n.querySelectorAll?.(\"*\").forEach((child) => {\n            if (child instanceof Element) applyDirectives(child, scope, disposers)\n          })\n        }\n      }\n\n      st.mounted = true\n      return\n    }\n\n    // unmount\n    if (!show && st.mounted) {\n      for (const n of st.nodes) n.parentNode?.removeChild(n)\n      st.nodes = []\n      st.mounted = false\n    }\n  })\n\n  disposers.push(dispose)\n}\n\ndirective(bindXIf)\n", "import { directive } from \"../core/directives.js\"\nimport { devAssert, devWarn, isPathSafe, unwrap } from \"../core/utils.js\"\n\nconst FOR_STATE = new WeakMap()\n\n/**\n * x-for on <template>\n *\n * Supported:\n *  <template x-for=\"item in items\">...</template>\n *  <template x-for=\"(item, i) in items\">...</template>\n *\n * Constraints:\n * - \"items\" must be a safe dot-path (no eval)\n */\nexport function bindXFor(ctx) {\n    const { el, scope, getAttr, getPath, effect, disposers, hydrate } = ctx\n\n    const expr = getAttr(el, \"x-for\")\n    if (!expr) return\n\n    devAssert(el.tagName.toLowerCase() === \"template\", `[sting] x-for can only be used on <template>`)\n\n    const parsed = parseForExpr(expr)\n    if (!parsed) {\n        devWarn(\n            `[sting] x-for invalid expression \"${expr}\". Expected: \"item in items\" or \"(item, i) in items\"`,\n            el\n        )\n        return\n    }\n\n    const { itemName, indexName, listPath } = parsed\n    devAssert(isPathSafe(listPath), `[sting] x-for list must be a safe path, got \"${listPath}\"`)\n\n    // state per-template\n    let st = FOR_STATE.get(el)\n    if (!st) {\n        st = {\n            nodes: /** @type {Node[]} */ ([]),\n            instanceDisposers: /** @type {Array<Array<() => void>>} */ ([]),\n            marker: document.createComment(\"sting:x-for\"),\n            initialized: false,\n        }\n        FOR_STATE.set(el, st)\n    }\n\n    // Ensure marker exists and is positioned right AFTER the template\n    if (!st.initialized) {\n        st.initialized = true\n        el.parentNode?.insertBefore(st.marker, el.nextSibling)\n    }\n\n    const dispose = effect(() => {\n        // 1) resolve list value\n        const resolved = getPath(scope, listPath)\n        let listVal = unwrap(resolved)\n        const items = normalizeIterable(listVal)\n\n        // 2) clear previous instances\n        clearForInstances(st)\n\n        // 3) render new instances\n        for (let i = 0; i < items.length; i++) {\n            const item = items[i]\n\n            // child scope inherits from parent scope\n            const childScope = Object.create(scope)\n            childScope[itemName] = item\n            if (indexName) childScope[indexName] = i\n\n            // clone\n            const frag = document.importNode(el.content, true)\n\n            // IMPORTANT: capture nodes BEFORE inserting (frag empties after insertion)\n            const newNodes = Array.from(frag.childNodes)\n\n            // insert AFTER template (before marker.nextSibling)\n            // marker is after template; inserting at marker means \"just before marker\" which is correct\n            st.marker.parentNode?.insertBefore(frag, st.marker)\n\n            // track inserted nodes\n            for (const n of newNodes) st.nodes.push(n)\n\n            // per-instance disposers\n            const localDisposers = []\n            st.instanceDisposers.push(localDisposers)\n\n            // hydrate inserted element subtrees\n            for (const n of newNodes) {\n                if (n.nodeType === Node.ELEMENT_NODE) {\n                    hydrate(/** @type {Element} */(n), childScope, localDisposers)\n                }\n            }\n        }\n    })\n\n    // component cleanup\n    disposers.push(() => {\n        try {\n            dispose()\n        } finally {\n            clearForInstances(st)\n            // remove marker too (optional but keeps DOM clean)\n            try { st.marker.parentNode?.removeChild(st.marker) } catch { }\n            FOR_STATE.delete(el)\n        }\n    })\n}\n\ndirective(bindXFor)\n\n/**\n * Parse x-for expression.\n *\n * @param {string} expr\n * @returns {{ itemName: string, indexName: string | null, listPath: string } | null}\n */\nfunction parseForExpr(expr) {\n    // \"(item, i) in items\" OR \"item in items\"\n    const m = expr.trim().match(/^\\s*(\\([^)]+\\)|[A-Za-z_$][\\w$]*)\\s+in\\s+(.+?)\\s*$/)\n    if (!m) return null\n\n    const lhs = m[1].trim()\n    const listPath = m[2].trim()\n\n    let itemName = \"\"\n    let indexName = \"\"\n\n    if (lhs.startsWith(\"(\")) {\n        const inner = lhs.slice(1, -1)\n        const parts = inner.split(\",\").map(s => s.trim()).filter(Boolean)\n        if (parts.length < 1) return null\n        itemName = parts[0]\n        indexName = parts[1] || \"\"\n    } else {\n        itemName = lhs\n    }\n\n    if (!/^[A-Za-z_$][\\w$]*$/.test(itemName)) return null\n    if (indexName && !/^[A-Za-z_$][\\w$]*$/.test(indexName)) return null\n\n    return { itemName, indexName: indexName || null, listPath }\n}\n\nfunction normalizeIterable(val) {\n    if (Array.isArray(val)) return val\n    if (val == null) return []\n    if (typeof val[Symbol.iterator] === \"function\") return Array.from(val)\n    return []\n}\n\nfunction clearForInstances(st) {\n    // dispose instance-level watchers/listeners\n    for (const ds of st.instanceDisposers) {\n        for (let i = ds.length - 1; i >= 0; i--) {\n            try { ds[i]() } catch { }\n        }\n    }\n    st.instanceDisposers.length = 0\n\n    // remove inserted nodes\n    for (const n of st.nodes) {\n        try { n.parentNode?.removeChild(n) } catch { }\n    }\n    st.nodes.length = 0\n}\n", "import { directive } from \"../core/directives.js\"\nimport { devAssert, devWarn, isPathSafe } from \"../core/utils.js\"\n\nexport function bindXEffect(ctx) {\n  const { el, scope, getAttr, getPath, effect, disposers } = ctx\n\n  const expr = getAttr(el, \"x-effect\")\n  if (!expr) return\n\n  devAssert(isPathSafe(expr), `[sting] x-effect invalid path \"${expr}\"`)\n\n  const dispose = effect(() => {\n    const fn = getPath(scope, expr)\n    if (typeof fn !== \"function\") {\n      devWarn(`[sting] x-effect \"${expr}\" is not a function`, el)\n      return\n    }\n    try {\n      // allow cleanup return\n      return fn.length > 0 ? fn(el, scope) : fn()\n    } catch (e) {\n      devWarn(`[sting] x-effect \"${expr}\" threw`, e)\n    }\n  })\n\n  disposers.push(dispose)\n}\n\ndirective(bindXEffect)\n"],
  "mappings": "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",
  "names": ["data", "getAttr", "getPath", "effect", "getAttr", "getPath", "effect", "getPath", "getAttr", "getPath", "effect", "untrack", "getAttr", "getPath", "setPath", "effect", "next", "getPath", "effect", "getAttr", "getPath", "effect", "getAttr", "getPath", "effect", "getAttr", "getPath", "effect"]
}
