{
  "version": 3,
  "sources": ["../sting/entry/entry-global.js", "../sting/core/index.js", "../sting/core/reactivity.js", "../sting/core/store.js", "../sting/core/registry.js", "../sting/core/directives.js", "../sting/core/runtime.js", "../sting/entry/shared.js", "../sting/directives/x-text.js", "../sting/directives/x-show.js", "../sting/directives/x-on.js", "../sting/directives/x-debug.js"],
  "sourcesContent": ["import { makeSting } from \"./shared.js\"\n\nimport \"../directives/x-text.js\"\nimport \"../directives/x-show.js\"\nimport \"../directives/x-on.js\"\nimport \"../directives/x-debug.js\"\n\nconst stingInstance = makeSting()\nstingInstance.autoStart()\n\nexport default stingInstance\n", "// Internal barrel export (no side effects)\n// Used by entry points to import all core functionality\n\nexport { signal, effect, batch, untrack } from \"./reactivity.js\"\nexport { store, produce } from \"./store.js\"\nexport { data } from \"./registry.js\"\nexport { start } from \"./runtime.js\"\nexport { directive, use, binders } from \"./directives.js\"\n", "/**\n * A reactive computation runner that can be subscribed to signals.\n * It also tracks which signal observer-sets it is currently subscribed to.\n *\n * @typedef {(() => void) & { deps: Set<Set<Runner>> }} Runner\n */\n\n/**\n * Global pointer to the currently running reactive computation (effect).\n * When a signal is read and Listener is set, the signal registers Listener\n * as a subscriber.\n *\n * @type {null | Runner}\n */\nlet Listener = null\n\n/**\n * When batching, signal writes queue effects here instead of running immediately.\n * @type {null | Set<Runner>}\n */\nlet BatchQueue = null\n\n/**\n * Run multiple signal updates with a single flush of effects at the end.\n *\n * @template T\n * @param {() => T} fn\n * @returns {T}\n *\n * @example\n * batch(() => {\n *   setA(1)\n *   setB(2)\n * })\n */\nexport function batch(fn) {\n    const prev = BatchQueue\n    const queue = new Set()\n    BatchQueue = queue\n    try {\n        return fn()\n    } finally {\n        // Restore previous batch (supports nesting)\n        BatchQueue = prev\n\n        // Only flush if we are the top-level batch\n        if (!prev) {\n            for (const runner of queue) runner()\n        } else {\n            // Merge into parent batch\n            for (const runner of queue) prev.add(runner)\n        }\n    }\n}\n\n/**\n * Create a reactive signal (a single reactive value).\n *\n * @template T\n * @param {T} initial Initial value.\n * @returns {[() => T, (next: T | ((prev: T) => T)) => T]} A getter and setter.\n *\n * @example\n * const [count, setCount] = signal(0)\n * effect(() => console.log(count()))\n * setCount(c => c + 1)\n */\nexport function signal(initial) {\n    let value = initial\n    /** @type {Set<Runner>} */\n    const observers = new Set()\n\n    /**\n     * Read current value. If an effect is running, subscribe it.\n     * @returns {any}\n     */\n    function read() {\n        if (Listener) {\n            observers.add(Listener)\n            Listener.deps.add(observers)\n        }\n        return value\n    }\n\n    /**\n     * Write a new value. Notifies subscribed effects if the value changed.\n     * @param {any} next\n     * @returns {any} The updated value.\n     */\n    function write(next) {\n        const nextValue = typeof next === \"function\" ? next(value) : next\n        if (Object.is(nextValue, value)) return value\n\n        value = nextValue\n        if (BatchQueue) {\n            for (const fn of observers) BatchQueue.add(fn)\n        } else {\n            const toRun = Array.from(observers)\n            for (const fn of toRun) fn()\n        }\n        return value\n    }\n\n    read._debugObservers = observers\n    return [read, write]\n}\n\n/**\n * Create a reactive effect (a computation that re-runs when its dependencies change).\n * Dependencies are tracked automatically by observing which signals are read while\n * the effect runs.\n *\n * NOTE (MVP): this doesn't yet implement dependency cleanup/unsubscribe.\n *\n * @param {() => void} fn\n * @returns {() => void} dispose function (currently a no-op placeholder)\n *\n * @example\n * const [count, setCount] = signal(0)\n * const dispose = effect(() => console.log(count()))\n * setCount(1) // triggers effect\n */\nexport function effect(fn) {\n    let disposed = false\n    /** @type {Runner} */\n    const runner = /** @type {any} */ (function run() {\n        if (disposed) return\n        // Unsubscribe from previous dependencies (if any)\n        for (const depObservers of runner.deps) {\n            depObservers.delete(runner)\n        }\n        runner.deps.clear()\n\n        // Set \"current running effect\"\n        const prev = Listener\n        Listener = runner\n        try {\n            fn()\n        } finally {\n            Listener = prev\n        }\n    })\n\n    runner.deps = new Set()\n\n    // Initial run\n    runner()\n\n    // Dispose: unsubscribe and make it inert\n    return function dispose() {\n        if (disposed) return\n        disposed = true\n\n        for (const depObservers of runner.deps) {\n            depObservers.delete(runner)\n        }\n        runner.deps.clear()\n    }\n}\n\n/**\n * Run a function without collecting reactive dependencies.\n * Equivalent to SolidJS untrack().\n *\n * @template T\n * @param {() => T} fn\n * @returns {T}\n */\nexport function untrack(fn) {\n    const prev = Listener\n    Listener = null\n    try {\n        return fn()\n    } finally {\n        Listener = prev\n    }\n}\n", "import { signal } from \"./reactivity.js\"\n\n/**\n * Produce helper: takes a \"mutate the draft\" function and returns an updater\n * function suitable for setStore(updater).\n *\n * @template T\n * @param {(draft: T) => void} mutator\n * @returns {(prev: T) => T}\n *\n * @example\n * setUser(produce(d => { d.name = \"Frodo\" }))\n */\nexport function produce(mutator) {\n    return (prev) => {\n        // MVP clone strategy:\n        // - structuredClone if available (handles more types)\n        // - fallback JSON clone (loses Dates/Maps/functions/etc)\n        const draft =\n            typeof structuredClone === \"function\"\n                ? structuredClone(prev)\n                : JSON.parse(JSON.stringify(prev))\n\n        mutator(draft)\n        return draft\n    }\n}\n\n/**\n * Create a store for nested objects.\n * This MVP store is \"signal-backed\":\n * - the whole object lives in a signal\n * - the returned Proxy reads from that signal (so effects track)\n * - writes use produce to replace the object\n *\n * @template {Record<string, any>} T\n * @param {T} initial\n * @returns {[T, (next: T | ((prev: T) => T)) => void]}\n *\n * @example\n * const [user, setUser] = store({ name: \"Sam\" })\n * effect(() => console.log(user.name))\n * setUser(produce(d => { d.name = \"Frodo\" }))\n */\nexport function store(initial) {\n    const [get, set] = signal(initial)\n\n    /** @type {any} */\n    const proxy = new Proxy(\n        {},\n        {\n            get(_target, prop) {\n                // allow inspection and symbols\n                if (prop === Symbol.toStringTag) return \"StingStore\"\n                if (prop === \"__raw\") return get()\n\n                const cur = get()\n                return cur?.[prop]\n            },\n\n            set(_target, prop, value) {\n                set(\n                    produce((d) => {\n                        d[prop] = value\n                    })\n                )\n                return true\n            },\n\n            ownKeys() {\n                return Reflect.ownKeys(get() ?? {})\n            },\n\n            getOwnPropertyDescriptor(_target, prop) {\n                const cur = get()\n                if (cur && prop in cur) {\n                    return { enumerable: true, configurable: true }\n                }\n            },\n        }\n    )\n\n    /**\n     * Set store value.\n     * Accepts:\n     * - a new object\n     * - an updater(prev) => next (including produce(...))\n     *\n     * @param {any} next\n     */\n    function setStore(next) {\n        set(next)\n    }\n\n    return [proxy, setStore]\n}\n", "/** @type {Map<string, () => any>} */\nconst registry = new Map()\n\n/**\n * Register a component factory by name.\n * x-data=\"name\" will call this factory to create the component scope.\n *\n * CSP-friendly rule: name is an identifier; not an expression.\n *\n * @param {string} name\n * @param {() => any} factory\n */\nexport function data(name, factory) {\n    registry.set(name, factory)\n}\n\n/**\n * Get a component factory by name.\n * Internal use only.\n *\n * @param {string} name\n * @returns {(() => any) | undefined}\n */\nexport function getFactory(name) {\n    return registry.get(name)\n}\n", "/**\n * A directive binder function.\n *\n * @typedef {(ctx: import('./runtime.js').DirectiveContext) => void} DirectiveBinder\n */\n\n/** @type {DirectiveBinder[]} */\nexport const binders = []\n\n/** @type {Set<DirectiveBinder>} */\nconst binderSet = new Set()\n\n/**\n * Register a directive binder.\n * Idempotent: registering the same binder twice is a no-op.\n *\n * @param {DirectiveBinder} binder\n * @returns {() => void} unregister function\n */\nexport function directive(binder) {\n    if (!binderSet.has(binder)) {\n        binderSet.add(binder)\n        binders.push(binder)\n    }\n\n    // optional: allow unregistering (handy for tests/devtools)\n    return () => {\n        if (!binderSet.delete(binder)) return\n        const i = binders.indexOf(binder)\n        if (i >= 0) binders.splice(i, 1)\n    }\n}\n\n/**\n * Install a plugin.\n * A plugin is a function that receives the Sting API.\n *\n * @param {(sting: { directive: typeof directive }) => void} plugin\n */\nexport function use(plugin) {\n    plugin({ directive })\n}\n", "import { effect, untrack } from \"./reactivity.js\"\nimport { getFactory } from \"./registry.js\"\nimport { binders } from \"./directives.js\"\n\n/**\n * Context passed to directive binders.\n *\n * @typedef {Object} DirectiveContext\n * @property {Element} el\n *   The DOM element currently being processed.\n * @property {any} scope\n *   Component scope returned by the x-data factory.\n * @property {(el: Element, name: string) => string | null} getAttr\n *   Reads an attribute from an element.\n * @property {(scope: any, path: string) => any} resolvePath\n *   Resolves a CSP-safe dot-path (e.g. \"user.name\") against scope.\n * @property {(fn: () => void) => () => void} effect\n *   Creates a reactive effect; returns a disposer.\n * @property {<T>(fn: () => T) => T} untrack\n *   Reads values without collecting dependencies.\n * @property {Array<() => void>} disposers\n *   Per-component cleanup functions.\n */\n\n/**\n * Get an attribute from an element.\n * @param {Element} el\n * @param {string} name\n * @returns {string | null}\n */\nfunction getAttr(el, name) {\n    return el.getAttribute(name)\n}\n\n/**\n * Walk the element subtree depth-first.\n * @param {Element} root\n * @param {(el: Element) => void} fn\n */\nfunction walk(root, fn) {\n    /** @type {Element[]} */\n    const stack = [root]\n    while (stack.length) {\n        const node = stack.pop()\n        if (!node) continue\n        fn(node)\n        for (let i = node.children.length - 1; i >= 0; i--) {\n            stack.push(node.children[i])\n        }\n    }\n}\n\n/**\n * Resolve a dot-path like \"user.name\" against a scope object.\n * CSP-friendly: only identifiers + dot access (no calls/operators).\n *\n * @param {any} scope\n * @param {string} path\n * @returns {any}\n */\nfunction resolvePath(scope, path) {\n    const parts = path.split(\".\").map((s) => s.trim()).filter(Boolean)\n    let cur = scope\n    for (const p of parts) cur = cur?.[p]\n    return cur\n}\n\n/**\n * Mount a component root: creates the scope and binds directives in its subtree.\n *\n * Returns a destroy function that removes event listeners and disposes effects\n * created for this component only.\n *\n * @param {Element} rootEl\n * @returns {(() => void) | undefined}\n */\nfunction mountComponent(rootEl) {\n    const name = getAttr(rootEl, \"x-data\")\n    if (!name) return\n\n    const factory = getFactory(name)\n    if (!factory) {\n        console.warn(`[sting] unknown component \"${name}\"`, rootEl)\n        return\n    }\n\n    const scope = factory()\n\n    /** @type {Array<() => void>} */\n    const disposers = [] // \u2705 per-component, not global\n\n    walk(rootEl, (el) => {\n        /** @type {DirectiveContext} */\n        const ctx = {\n            el,\n            scope,\n            getAttr,\n            resolvePath,\n            effect,\n            untrack,\n            disposers,\n        }\n\n        for (const bind of binders) {\n            bind(ctx)\n        }\n    })\n\n    return () => {\n        for (let i = disposers.length - 1; i >= 0; i--) {\n            try {\n                disposers[i]()\n            } catch (e) {\n                console.error(\"[sting] error during disposer\", e)\n            }\n        }\n    }\n}\n\n/**\n * Start StingJS on a root node.\n * Finds all elements with x-data and mounts them.\n *\n * Returns a stop() function that unmounts everything mounted by this call.\n *\n * @param {Document | Element} root\n * @returns {() => void}\n */\nexport function start(root = document) {\n    const roots = root.querySelectorAll(\"[x-data]\")\n    const destroys = new Map()\n\n    for (const el of roots) {\n        const destroy = mountComponent(el)\n        if (destroy) destroys.set(el, destroy)\n    }\n\n    const mo = new MutationObserver((mutations) => {\n        for (const m of mutations) {\n            for (const node of m.removedNodes) {\n                if (!(node instanceof Element)) continue\n\n                // if the removed node IS a root\n                if (destroys.has(node)) {\n                    destroys.get(node)()\n                    destroys.delete(node)\n                }\n\n                // if it CONTAINS roots\n                node.querySelectorAll?.(\"[x-data]\").forEach((el) => {\n                    if (destroys.has(el)) {\n                        destroys.get(el)()\n                        destroys.delete(el)\n                    }\n                })\n            }\n        }\n    })\n\n    mo.observe(root === document ? document.body : root, { childList: true, subtree: true })\n\n    return () => {\n        mo.disconnect()\n        for (const destroy of destroys.values()) destroy()\n        destroys.clear()\n    }\n}\n", "import * as core from \"../core/index.js\"\n\nexport function makeSting() {\n  let started = false\n\n  function ensureStarted() {\n    if (started) return\n    started = true\n    core.start() // mounts existing [x-data] + sets up mutation observer\n  }\n\n  function autoStart() {\n    // Safety net: start when DOM is ready\n    if (document.readyState === \"loading\") {\n      document.addEventListener(\"DOMContentLoaded\", ensureStarted, { once: true })\n    } else {\n      ensureStarted()\n    }\n  }\n\n  // Wrap data() so first registration triggers start\n  function data(name, factory) {\n    core.data(name, factory) // Register first\n    ensureStarted() // Then start\n  }\n\n  return {\n    ...core,\n    data,\n    autoStart,\n    start: ensureStarted\n  }\n}\n", "import { directive } from \"../core/directives.js\"\n\n/**\n * Bind the `x-text` directive.\n *\n * Keeps `el.textContent` in sync with a reactive expression.\n *\n * Example:\n *   <span x-text=\"user.name\"></span>\n *\n * Behavior:\n * - Evaluates the expression against the component scope.\n * - Re-runs automatically when any accessed signal changes.\n * - Updates textContent with the resolved value (or empty string if null/undefined).\n *\n * @param {import(\"../sting/sting.js\").DirectiveContext} ctx\n */\nexport function bindXText(ctx) {\n  const { el, scope, getAttr, resolvePath, effect, disposers } = ctx\n\n  const expr = getAttr(el, \"x-text\")\n  if (!expr) return\n\n  const dispose = effect(() => {\n    const value = resolvePath(scope, expr)\n    el.textContent = value ?? \"\"\n  })\n\n  disposers.push(dispose)\n}\n\ndirective(bindXText)\n", "import { directive } from \"../core/directives.js\"\n\n/**\n * Bind the `x-show` directive.\n *\n * Toggles element visibility using `display: none` based on a reactive value.\n *\n * Example:\n *   <div x-show=\"open\"></div>\n *\n * Behavior:\n * - Truthy value \u2192 element is shown\n * - Falsy value \u2192 element is hidden (`display: none`)\n * - Preserves the element\u2019s original inline `display` style\n *\n * @param {import(\"../sting/sting.js\").DirectiveContext} ctx\n */\nexport function bindXShow(ctx) {\n  const { el, scope, getAttr, resolvePath, effect, disposers } = ctx\n\n  const expr = getAttr(el, \"x-show\")\n  if (!expr) return\n\n  const initialDisplay = el.style.display\n\n  const dispose = effect(() => {\n    const value = resolvePath(scope, expr)\n    el.style.display = value ? initialDisplay : \"none\"\n  })\n\n  disposers.push(dispose)\n}\n\ndirective(bindXShow)", "import { directive } from \"../core/directives.js\"\n\n/**\n * Bind `x-on:*` event directives.\n *\n * Supports arbitrary DOM events.\n *\n * Examples:\n *   <button x-on:click=\"submit\"></button>\n *   <input x-on:input=\"onInput\"></input>\n *\n * Behavior:\n * - Looks for all attributes starting with `x-on:`\n * - Resolves the attribute value to a function in component scope\n * - Attaches a DOM event listener\n * - Automatically removes the listener when the component is destroyed\n *\n * @param {import(\"../sting/sting.js\").DirectiveContext} ctx\n */\nexport function bindXOn(ctx) {\n  const { el, scope, resolvePath, disposers } = ctx\n\n  for (const attr of el.attributes) {\n    if (!attr.name.startsWith(\"x-on:\")) continue\n\n    const eventName = attr.name.slice(5)\n    const handlerFn = resolvePath(scope, attr.value)\n\n    if (typeof handlerFn !== \"function\") {\n      console.warn(`[sting] ${attr.name}=\"${attr.value}\" is not a function`, el)\n      continue\n    }\n\n    const handler = (e) => handlerFn(e)\n    el.addEventListener(eventName, handler)\n    disposers.push(() => el.removeEventListener(eventName, handler))\n  }\n}\n\ndirective(bindXOn)", "import { directive } from \"../core/directives.js\"\n\n/**\n * Bind the `x-debug` directive.\n *\n * Renders live debug information about a signal directly into the DOM.\n * Intended for development only.\n *\n * Examples:\n *   <div x-debug=\"$open\"></div>\n *   <div x-debug=\"open\"></div> // will try `$open` automatically\n *\n * Behavior:\n * - Displays the current signal value\n * - Displays the number of subscribed observers\n * - Subscribes to the signal so the debug output stays live\n * - Uses `untrack()` when reading values to avoid feedback loops\n *\n * @param {import(\"../sting/sting.js\").DirectiveContext} ctx\n */\nexport function bindXDebug(ctx) {\n  const { el, scope, getAttr, resolvePath, effect, untrack, disposers } = ctx\n\n  const expr = getAttr(el, \"x-debug\")\n  if (!expr) return\n\n  let sig = resolvePath(scope, expr)\n\n  // If the value facade was passed (e.g. \"open\"), try \"$open\"\n  if (typeof sig !== \"function\") {\n    sig = resolvePath(scope, `$${expr}`)\n  }\n\n  const dispose = effect(() => {\n    if (typeof sig !== \"function\") {\n      el.textContent = `debug(${expr}): not a signal getter`\n      return\n    }\n\n    // Subscribe so this effect reruns when the signal changes\n    sig()\n\n    // Read without tracking to avoid self-triggering loops\n    const value = untrack(() => sig())\n    const observers = sig._debugObservers?.size ?? \"?\"\n\n    el.textContent =\n      `debug(${expr}): value=${String(value)} observers=${observers}`\n  })\n\n  disposers.push(dispose)\n}\n\ndirective(bindXDebug)"],
  "mappings": "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",
  "names": ["data", "getAttr", "resolvePath", "effect", "getAttr", "resolvePath", "effect", "resolvePath", "getAttr", "resolvePath", "effect", "untrack"]
}
