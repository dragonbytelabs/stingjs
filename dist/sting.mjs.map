{
  "version": 3,
  "sources": ["../sting/core/index.js", "../sting/core/utils.js", "../sting/core/reactivity.js", "../sting/core/store.js", "../sting/core/registry.js", "../sting/core/directives.js", "../sting/core/runtime.js", "../sting/entry/shared.js", "../sting/directives/x-text.js", "../sting/directives/x-show.js", "../sting/directives/x-on.js", "../sting/directives/x-debug.js", "../sting/directives/x-model.js", "../sting/directives/x-bind.js", "../sting/entry/entry-esm.js"],
  "sourcesContent": ["export { signal, effect, batch, untrack, computed } from \"./reactivity.js\"\nexport { store, produce } from \"./store.js\"\nexport { data } from \"./registry.js\"\nexport { start } from \"./runtime.js\"\nexport { directive, use, binders } from \"./directives.js\"\nexport * from \"./utils.js\"\n", "/**\n * @typedef {Error & { code?: string }} StingError\n */\n\n/**\n * True if we should run dev-only checks/logs.\n * @type {boolean}\n */\nexport const __DEV__ = typeof __DEV__ !== \"undefined\" ? __DEV__ : true\n\n/**\n * Assert an invariant \n * If this fails, StingJS is in a state it doesn't know how to recover from.\n *\n * @param {any} condition\n * @param {string} message\n * @param {{ code?: string, cause?: any }=} options\n * @returns {asserts condition}\n */\nexport function assert(condition, message, options) {\n  if (condition) return\n  const err = /** @type {StingError} */ (new Error(message))\n  if (options?.code) err.code = options.code\n  if (options?.cause) err.cause = options.cause\n  throw err\n}\n\n/**\n * Dev-only assert. \n *\n * @param {any} condition\n * @param {string} message\n * @returns {asserts condition}\n */\nexport function devAssert(condition, message) {\n  if (!__DEV__) return\n  assert(condition, message)\n}\n\n/**\n * Dev-only warning (user misuse, not engine corruption).\n *\n * @param {string} message\n * @param {any=} extra\n */\nexport function devWarn(message, extra) {\n  if (!__DEV__) return\n  if (extra !== undefined) console.warn(message, extra)\n  else console.warn(message)\n}\n\n/**\n * Helper: safer string tag name for elements.\n * @param {Element} el\n */\nexport function elementTag(element) {\n  return element?.tagName?.toLowerCase?.() ?? \"\"\n}\n\n/**\n * Check if a path string is safe to eval.\n * Only allows simple dot-separated identifiers.\n *\n * @param {string} path\n * @returns {boolean}\n */\nexport function isPathSafe(path) {\n  if (typeof path !== \"string\") return false\n  return /^[A-Za-z_$][\\w$]*(\\.[A-Za-z_$][\\w$]*)*$/.test(path)\n}\n\n/**\n * Unwrap a signal or return the value as-is.\n *\n * @template T\n * @param {T | (() => T)} signal\n * @returns {T}\n */\nexport function unwrap(signal) {\n  return typeof signal === \"function\" ? signal() : signal\n}", "import { devAssert } from \"./utils.js\"\n\n/**\n * A reactive computation runner that can be subscribed to signals.\n * It also tracks which signal observer-sets it is currently subscribed to.\n *\n * @typedef {(() => void) & { deps: Set<Set<Runner>> }} Runner\n */\n\n/**\n * Global pointer to the currently running reactive computation (effect).\n * When a signal is read and Listener is set, the signal registers Listener\n * as a subscriber.\n *\n * @type {null | Runner}\n */\nlet Listener = null\n\n/**\n * When batching, signal writes queue effects here instead of running immediately.\n * @type {null | Set<Runner>}\n */\nlet BatchQueue = null\n\n/**\n * Run multiple signal updates with a single flush of effects at the end.\n *\n * @template T\n * @param {() => T} fn\n * @returns {T}\n *\n * @example\n * batch(() => {\n *   setA(1)\n *   setB(2)\n * })\n */\nexport function batch(fn) {\n    const prev = BatchQueue\n    const queue = new Set()\n    BatchQueue = queue\n    try {\n        return fn()\n    } finally {\n        // Restore previous batch (supports nesting)\n        BatchQueue = prev\n\n        // Only flush if we are the top-level batch\n        if (!prev) {\n            for (const runner of queue) runner()\n        } else {\n            // Merge into parent batch\n            for (const runner of queue) prev.add(runner)\n        }\n    }\n}\n\n/**\n * Create a reactive signal (a single reactive value).\n *\n * @template T\n * @param {T} initial Initial value.\n * @returns {[() => T, (next: T | ((prev: T) => T)) => T]} A getter and setter.\n *\n * @example\n * const [count, setCount] = signal(0)\n * effect(() => console.log(count()))\n * setCount(c => c + 1)\n */\nexport function signal(initial) {\n    let value = initial\n    /** @type {Set<Runner>} */\n    const observers = new Set()\n\n    /**\n     * Read current value. If an effect is running, subscribe it.\n     * @returns {any}\n     */\n    function read() {\n        if (Listener) {\n            observers.add(Listener)\n            Listener.deps.add(observers)\n        }\n        return value\n    }\n\n    /**\n     * Write a new value. Notifies subscribed effects if the value changed.\n     * @param {any} next\n     * @returns {any} The updated value.\n     */\n    function write(next) {\n        devAssert(observers instanceof Set, \"[sting] signal observers must be a Set\")\n\n        const nextValue = typeof next === \"function\" ? next(value) : next\n        if (Object.is(nextValue, value)) return value\n\n        value = nextValue\n        if (BatchQueue) {\n            for (const fn of observers) BatchQueue.add(fn)\n        } else {\n            const toRun = Array.from(observers)\n            for (const fn of toRun) fn()\n        }\n        return value\n    }\n\n    read._debugObservers = observers\n    return [read, write]\n}\n\n/**\n * Create a reactive effect (a computation that re-runs when its dependencies change).\n * Dependencies are tracked automatically by observing which signals are read while\n * the effect runs.\n *\n * @param {() => void} fn\n * @returns {() => void} dispose function (currently a no-op placeholder)\n *\n * @example\n * const [count, setCount] = signal(0)\n * const dispose = effect(() => console.log(count()))\n * setCount(1) // triggers effect\n */\nexport function effect(fn) {\n    let disposed = false\n    /** @type {Runner} */\n    const runner = /** @type {any} */ (function run() {\n        if (disposed) return\n        // Unsubscribe from previous dependencies (if any)\n        for (const depObservers of runner.deps) {\n            depObservers.delete(runner)\n        }\n        runner.deps.clear()\n\n        // Set \"current running effect\"\n        const prev = Listener\n        Listener = runner\n        try {\n            fn()\n        } finally {\n            Listener = prev\n        }\n    })\n\n    runner.deps = new Set()\n\n    // Initial run\n    runner()\n\n    // Dispose: unsubscribe and make it inert\n    return function dispose() {\n        if (disposed) return\n        disposed = true\n\n        for (const depObservers of runner.deps) {\n            depObservers.delete(runner)\n        }\n        runner.deps.clear()\n    }\n}\n\n/**\n * Create a computed signal (a read-only signal derived from other signals).\n *\n * @param {() => any} fn\n * @returns {() => any} getter function\n * \n * @example\n * const [count, setCount] = signal(0)\n * const double = computed(() => count() * 2)\n * effect(() => console.log(double()))\n * setCount(1) // triggers effect, logs 2\n */\nexport function computed(fn) {\n  const [get, set] = signal(undefined)\n\n  const dispose = effect(() => {\n    set(fn())\n  })\n\n  get.dispose = dispose\n  return get\n}\n\n/**\n * Run a function without collecting reactive dependencies.\n *\n * @template T\n * @param {() => T} fn\n * @returns {T}\n */\nexport function untrack(fn) {\n    const prev = Listener\n    Listener = null\n    try {\n        return fn()\n    } finally {\n        Listener = prev\n    }\n}\n", "import { signal } from \"./reactivity.js\"\n\n/**\n * Produce helper: takes a \"mutate the draft\" function and returns an updater\n * function suitable for setStore(updater).\n *\n * @template T\n * @param {(draft: T) => void} mutator\n * @returns {(prev: T) => T}\n *\n * @example\n * setUser(produce(d => { d.name = \"Frodo\" }))\n */\nexport function produce(mutator) {\n    return (prev) => {\n        // MVP clone strategy:\n        // - structuredClone if available (handles more types)\n        // - fallback JSON clone (loses Dates/Maps/functions/etc)\n        const draft =\n            typeof structuredClone === \"function\"\n                ? structuredClone(prev)\n                : JSON.parse(JSON.stringify(prev))\n\n        mutator(draft)\n        return draft\n    }\n}\n\n/**\n * Create a store for nested objects.\n * This MVP store is \"signal-backed\":\n * - the whole object lives in a signal\n * - the returned Proxy reads from that signal (so effects track)\n * - writes use produce to replace the object\n *\n * @template {Record<string, any>} T\n * @param {T} initial\n * @returns {[T, (next: T | ((prev: T) => T)) => void]}\n *\n * @example\n * const [user, setUser] = store({ name: \"Sam\" })\n * effect(() => console.log(user.name))\n * setUser(produce(d => { d.name = \"Frodo\" }))\n */\nexport function store(initial) {\n    const [get, set] = signal(initial)\n\n    /** @type {any} */\n    const proxy = new Proxy(\n        {},\n        {\n            get(_target, prop) {\n                // allow inspection and symbols\n                if (prop === Symbol.toStringTag) return \"StingStore\"\n                if (prop === \"__raw\") return get()\n\n                const cur = get()\n                return cur?.[prop]\n            },\n\n            set(_target, prop, value) {\n                set(\n                    produce((d) => {\n                        d[prop] = value\n                    })\n                )\n                return true\n            },\n\n            ownKeys() {\n                return Reflect.ownKeys(get() ?? {})\n            },\n\n            getOwnPropertyDescriptor(_target, prop) {\n                const cur = get()\n                if (cur && prop in cur) {\n                    return { enumerable: true, configurable: true }\n                }\n            },\n        }\n    )\n\n    /**\n     * Set store value.\n     * Accepts:\n     * - a new object\n     * - an updater(prev) => next (including produce(...))\n     *\n     * @param {any} next\n     */\n    function setStore(next) {\n        set(next)\n    }\n\n    return [proxy, setStore]\n}\n", "/** @type {Map<string, () => any>} */\nconst registry = new Map()\n\n/**\n * Register a component factory by name.\n * x-data=\"name\" will call this factory to create the component scope.\n *\n * @param {string} name\n * @param {() => any} factory\n */\nexport function data(name, factory) {\n    registry.set(name, factory)\n}\n\n/**\n * Get a component factory by name.\n * Internal use only.\n *\n * @param {string} name\n * @returns {(() => any) | undefined}\n */\nexport function getFactory(name) {\n    return registry.get(name)\n}\n", "/**\n * A directive binder function.\n *\n * @typedef {(ctx: import('./runtime.js').DirectiveContext) => void} DirectiveBinder\n */\n\n/** @type {DirectiveBinder[]} */\nexport const binders = []\n\n/** @type {Set<DirectiveBinder>} */\nconst binderSet = new Set()\n\n/**\n * Register a directive binder.\n * Idempotent: registering the same binder twice is a no-op.\n *\n * @param {DirectiveBinder} binder\n * @returns {() => void} unregister function\n */\nexport function directive(binder) {\n    if (!binderSet.has(binder)) {\n        binderSet.add(binder)\n        binders.push(binder)\n    }\n\n    // optional: allow unregistering (handy for tests/devtools)\n    return () => {\n        if (!binderSet.delete(binder)) return\n        const i = binders.indexOf(binder)\n        if (i >= 0) binders.splice(i, 1)\n    }\n}\n\n/**\n * Install a plugin.\n * A plugin is a function that receives the Sting API.\n *\n * @param {(sting: { directive: typeof directive }) => void} plugin\n */\nexport function use(plugin) {\n    plugin({ directive })\n}\n", "import { effect, untrack } from \"./reactivity.js\"\nimport { getFactory } from \"./registry.js\"\nimport { binders } from \"./directives.js\"\nimport { devAssert, devWarn } from \"./utils.js\"\n\n\n/**\n * Context passed to directive binders.\n *\n * @typedef {Object} DirectiveContext\n * @property {Element} el\n *   The DOM element currently being processed.\n * @property {any} scope\n *   Component scope returned by the x-data factory.\n * @property {(el: Element, name: string) => string | null} getAttr\n *   Reads an attribute from an element.\n * @property {(scope: any, path: string) => any} getPath\n *   Gets a dot-path (e.g. \"user.name\") against scope.\n * @property {(scope: any, path: string, value: any) => void} setPath\n *   Sets a dot-path (e.g. \"user.name\") against scope.\n * @property {(fn: () => void) => () => void} effect\n *   Creates a reactive effect; returns a disposer.\n * @property {<T>(fn: () => T) => T} untrack\n *   Reads values without collecting dependencies.\n * @property {Array<() => void>} disposers\n *   Per-component cleanup functions.\n */\n\n/**\n * Get an attribute from an element.\n * @param {Element} el\n * @param {string} name\n * @returns {string | null}\n */\nfunction getAttr(el, name) {\n    return el.getAttribute(name)\n}\n\n/**\n * Walk the element subtree depth-first.\n * @param {Element} root\n * @param {(el: Element) => void} fn\n */\nfunction walk(root, fn) {\n    /** @type {Element[]} */\n    const stack = [root]\n    while (stack.length) {\n        const node = stack.pop()\n        if (!node) continue\n        fn(node)\n        for (let i = node.children.length - 1; i >= 0; i--) {\n            stack.push(node.children[i])\n        }\n    }\n}\n\n/**\n * Resolve a dot-path like \"user.name\" against a scope object.\n * \n * @param {any} scope\n * @param {string} path\n * @returns {any}\n */\nfunction getPath(scope, path) {\n    const parts = path.split(\".\").map((s) => s.trim()).filter(Boolean)\n    let cur = scope\n    for (const p of parts) cur = cur?.[p]\n    return cur\n}\n\n/**\n * Set a dot-path like \"user.name\" against a scope object.\n * \n * @param {any} scope\n * @param {string} path\n * @param {any} value\n */\nfunction setPath(scope, path, value) {\n    const parts = path.split(\".\").map((s) => s.trim()).filter(Boolean)\n    if (parts.length === 0) return\n    let cur = scope;\n    for (let i = 0; i < parts.length - 1; i++) {\n        const key = parts[i];\n        cur = cur?.[key]\n\n        if (cur == null) {\n            console.warn(`setPath: \"${path}\" not reachable (missing \"${key}\")`)\n            return\n        }\n    }\n\n    const last = parts[parts.length - 1];\n    cur[last] = value\n}\n\n/**\n * Mount a component root: creates the scope and binds directives in its subtree.\n *\n * Returns a destroy function that removes event listeners and disposes effects\n * created for this component only.\n *\n * @param {Element} rootEl\n * @returns {(() => void) | undefined}\n */\nfunction mountComponent(rootEl) {\n    devAssert(rootEl instanceof Element, \"[sting] mountComponent expects an Element\")\n\n    const name = getAttr(rootEl, \"x-data\")\n    devAssert(!!name, `[sting] mountComponent called without x-data`)\n\n    const factory = getFactory(name)\n    if (!factory) {\n        devWarn(\n            `[sting] component \"${name}\" not registered yet. ` +\n            `Did you call sting.data(\"${name}\", ...) before DOM ready?`,\n            rootEl\n        )\n        return\n    }\n\n    const scope = factory()\n\n    /** @type {Array<() => void>} */\n    const disposers = [] // \u2705 per-component, not global\n\n    walk(rootEl, (el) => {\n        /** @type {DirectiveContext} */\n        const ctx = {\n            el,\n            scope,\n            getAttr,\n            getPath,\n            setPath,\n            effect,\n            untrack,\n            disposers,\n        }\n\n        for (const bind of binders) {\n            bind(ctx)\n        }\n    })\n\n    return () => {\n        for (let i = disposers.length - 1; i >= 0; i--) {\n            try {\n                disposers[i]()\n            } catch (e) {\n                console.error(\"[sting] error during disposer\", e)\n            }\n        }\n    }\n}\n\n/**\n * Start StingJS on a root node.\n * Finds all elements with x-data and mounts them.\n *\n * Returns a stop() function that unmounts everything mounted by this call.\n *\n * @param {Document | Element} root\n * @returns {() => void}\n */\nexport function start(root = document) {\n    devAssert(root === document || root instanceof Element, \"[sting] start(root) expects Document or Element\")\n\n    const roots = root.querySelectorAll(\"[x-data]\")\n    const destroys = new Map()\n\n    for (const el of roots) {\n        const destroy = mountComponent(el)\n        if (destroy) destroys.set(el, destroy)\n    }\n\n    const mo = new MutationObserver((mutations) => {\n        for (const m of mutations) {\n            for (const node of m.removedNodes) {\n                if (!(node instanceof Element)) continue\n\n                // if the removed node IS a root\n                if (destroys.has(node)) {\n                    destroys.get(node)()\n                    destroys.delete(node)\n                }\n\n                // if it CONTAINS roots\n                node.querySelectorAll?.(\"[x-data]\").forEach((el) => {\n                    if (destroys.has(el)) {\n                        destroys.get(el)()\n                        destroys.delete(el)\n                    }\n                })\n            }\n        }\n    })\n\n    mo.observe(root === document ? document.body : root, { childList: true, subtree: true })\n\n    return () => {\n        mo.disconnect()\n        for (const destroy of destroys.values()) destroy()\n        destroys.clear()\n    }\n}\n", "import * as core from \"../core/index.js\"\n\nexport function makeSting() {\n    let started = false\n    let startQueued = false\n\n    function ensureStarted() {\n        if (started || startQueued) return\n        startQueued = true\n\n        queueMicrotask(() => {\n            startQueued = false\n            if (started) return\n            started = true\n            core.start()\n        })\n    }\n\n    let domReadyHooked = false\n    function autoStart() {\n        if (started || startQueued) return\n        if (document.readyState === \"loading\") {\n            if (domReadyHooked) return\n            domReadyHooked = true\n            document.addEventListener(\"DOMContentLoaded\", ensureStarted, { once: true })\n        } else {\n            ensureStarted()\n        }\n    }\n\n    function data(name, factory) {\n        core.devAssert(typeof name === \"string\" && name.length > 0, `[sting] data(name) requires a string name`)\n        core.devAssert(typeof factory === \"function\", `[sting] data(\"${name}\") requires a factory function`)\n        core.data(name, factory)\n        ensureStarted()\n    }\n\n\n    return {\n        ...core,\n        data,\n        autoStart,\n        start: ensureStarted\n    }\n}\n", "import { directive } from \"../core/directives.js\"\nimport { devAssert, isPathSafe, unwrap } from \"../core/utils.js\"\n\n/**\n * Bind the `x-text` directive.\n *\n * Keeps `el.textContent` in sync with a reactive expression.\n *\n * Example:\n *   <span x-text=\"user.name\"></span>\n *\n * Behavior:\n * - Evaluates the expression against the component scope.\n * - Re-runs automatically when any accessed signal changes.\n * - Updates textContent with the resolved value (or empty string if null/undefined).\n *\n * @param {import(\"../core/runtime.js\").DirectiveContext} ctx\n */\nexport function bindXText(ctx) {\n  const { el, scope, getAttr, getPath, effect, disposers } = ctx\n\n  const expr = getAttr(el, \"x-text\")\n  if (!expr) return\n\n  devAssert(isPathSafe(expr), `[sting] x-text invalid path \"${expr}\"`)\n\n  const dispose = effect(() => {\n    const value = unwrap(getPath(scope, expr))\n    el.textContent = value ?? \"\"\n  })\n\n  disposers.push(dispose)\n}\n\ndirective(bindXText)\n", "import { directive } from \"../core/directives.js\"\nimport { devAssert, isPathSafe, unwrap } from \"../core/utils.js\"\n\n/**\n * Bind the `x-show` directive.\n *\n * Toggles element visibility using `display: none` based on a reactive value.\n *\n * Example:\n *   <div x-show=\"open\"></div>\n *\n * Behavior:\n * - Truthy value \u2192 element is shown\n * - Falsy value \u2192 element is hidden (`display: none`)\n * - Preserves the element\u2019s original inline `display` style\n *\n * @param {import(\"../core/runtime.js\").DirectiveContext} ctx\n */\nexport function bindXShow(ctx) {\n  const { el, scope, getAttr, getPath, effect, disposers } = ctx\n\n  const expr = getAttr(el, \"x-show\")\n  if (!expr) return\n\n  devAssert(isPathSafe(expr), `[sting] x-show invalid path \"${expr}\"`)\n\n  const initialDisplay = el.style.display\n\n  const dispose = effect(() => {\n    const value = unwrap(getPath(scope, expr))\n    el.style.display = value ? initialDisplay : \"none\"\n  })\n\n  disposers.push(dispose)\n}\n\ndirective(bindXShow)", "import { directive } from \"../core/directives.js\"\nimport { devAssert, devWarn, isPathSafe } from \"../core/utils.js\"\n\n/**\n * Bind `x-on:*` event directives.\n *\n * @param {import(\"../core/runtime.js\").DirectiveContext} ctx\n */\nexport function bindXOn(ctx) {\n  const { el, scope, getPath, disposers } = ctx\n\n  // prevent duplicate listeners if the binder runs twice.\n  const bound = getOrInitBoundMap(el)\n\n  for (const attr of el.attributes) {\n    if (!attr.name.startsWith(\"x-on:\")) continue\n\n    const eventName = attr.name.slice(5).trim()\n    const expr = (attr.value ?? \"\").trim()\n\n    if (!eventName) {\n      devWarn(`[sting] invalid ${attr.name} (missing event name)`, el)\n      continue\n    }\n\n    if (!expr) {\n      devWarn(`[sting] ${attr.name} is missing a handler name`, el)\n      continue\n    }\n\n    devAssert(isPathSafe(expr), `[sting] ${attr.name} invalid handler path \"${expr}\"`)\n\n    // idempotency: avoid binding same event+expr twice on same element\n    const key = `${eventName}::${expr}`\n    if (bound.has(key)) continue\n\n    const handlerFn = getPath(scope, expr)\n    if (typeof handlerFn !== \"function\") {\n      devWarn(`[sting] ${attr.name}=\"${expr}\" is not a function`, el)\n      continue\n    }\n\n    const handler = (e) => handlerFn(e)\n\n    el.addEventListener(eventName, handler)\n    disposers.push(() => el.removeEventListener(eventName, handler))\n\n    bound.set(key, handler)\n  }\n}\n\ndirective(bindXOn)\n\n/** @type {WeakMap<Element, Map<string, Function>>} */\nconst _boundListeners = new WeakMap()\n\nfunction getOrInitBoundMap(el) {\n  let m = _boundListeners.get(el)\n  if (!m) {\n    m = new Map()\n    _boundListeners.set(el, m)\n  }\n  return m\n}\n", "import { directive } from \"../core/directives.js\"\nimport { devAssert, isPathSafe } from \"../core/utils.js\"\n\n/**\n * Bind the `x-debug` directive.\n *\n * Renders live debug information about a signal directly into the DOM.\n * Intended for development only.\n *\n * Examples:\n *   <div x-debug=\"$open\"></div>\n *   <div x-debug=\"open\"></div> // will try `$open` automatically\n *\n * Behavior:\n * - Displays the current signal value\n * - Displays the number of subscribed observers\n * - Subscribes to the signal so the debug output stays live\n * - Uses `untrack()` when reading values to avoid feedback loops\n *\n * @param {import(\"../sting/sting.js\").DirectiveContext} ctx\n */\nexport function bindXDebug(ctx) {\n  const { el, scope, getAttr, getPath, effect, untrack, disposers } = ctx\n\n  const expr = getAttr(el, \"x-debug\")\n  if (!expr) return\n\n  devAssert(isPathSafe(expr), `[sting] x-debug invalid path \"${expr}\"`)\n\n  let sig = getPath(scope, expr)\n\n  // If the value facade was passed (e.g. \"open\"), try \"$open\"\n  if (typeof sig !== \"function\") {\n    sig = getPath(scope, `$${expr}`)\n  }\n\n  const dispose = effect(() => {\n    if (typeof sig !== \"function\") {\n      el.textContent = `debug(${expr}): not a signal getter`\n      return\n    }\n\n    // Subscribe so this effect reruns when the signal changes\n    sig()\n\n    // Read without tracking to avoid self-triggering loops\n    const value = untrack(() => sig())\n    const observers = sig._debugObservers?.size ?? \"?\"\n\n    el.textContent =\n      `debug(${expr}): value=${String(value)} observers=${observers}`\n  })\n\n  disposers.push(dispose)\n}\n\ndirective(bindXDebug)", "import { directive } from \"../core/directives.js\"\nimport { devWarn, elementTag, devAssert, isPathSafe } from \"../core/utils.js\"\n\n/**\n * Bind the `x-model` directive.\n *\n * Two-way bind between a form control's value and a scope path.\n *\n * - scope -> DOM: reactive effect updates el.value when the model changes\n * - DOM -> scope: input/change event updates the model via setPath\n * \n * Example:\n *   <input type=\"text\" x-model=\"message\">\n *   <span x-text=\"message\"></span>\n *\n * Supports: <input>, <textarea>, <select>\n * (checkbox/radio handled too)\n *\n * @param {import(\"../core/runtime.js\").DirectiveContext} ctx\n */\nexport function bindXModel(ctx) {\n    const { el, scope, getAttr, getPath, setPath, effect, disposers } = ctx\n\n    const expr = getAttr(el, \"x-model\")\n    if (!expr) return\n\n    devAssert(isPathSafe(expr), `[sting] x-model invalid path \"${expr}\"`)\n\n    const tag = elementTag(el)\n    const isInput = tag === \"input\"\n    const isTextarea = tag === \"textarea\"\n    const isSelect = tag === \"select\"\n\n    if (!isInput && !isTextarea && !isSelect) {\n        devWarn(`[sting] x-model can only be used on input/textarea/select`, el)\n        return\n    }\n\n    devAssert(typeof expr === \"string\" && expr.length > 0, \"[sting] x-model expr must be a non-empty string\")\n\n    /** @type {HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement} */\n    const field = /** @type {any} */ (el)\n\n    const inputType = isInput ? /** @type {HTMLInputElement} */ (field).type : \"\"\n    const isCheckbox = isInput && inputType === \"checkbox\"\n    const isRadio = isInput && inputType === \"radio\"\n\n    const onInput = () => {\n        if (isCheckbox) {\n            setPath(scope, expr, /** @type {HTMLInputElement} */(field).checked)\n            return\n        }\n\n        if (isRadio) {\n            const radio = /** @type {HTMLInputElement} */ (field)\n            if (radio.checked) setPath(scope, expr, radio.value)\n            return\n        }\n\n        setPath(scope, expr, field.value)\n    }\n\n    // use `input` for text-like controls, `change` for select/checkbox/radio\n    const eventName = (isSelect || isCheckbox || isRadio) ? \"change\" : \"input\"\n    field.addEventListener(eventName, onInput)\n    disposers.push(() => field.removeEventListener(eventName, onInput))\n\n    const dispose = effect(() => {\n        const value = getPath(scope, expr)\n\n        if (isCheckbox) {\n            const next = !!value\n            if (/** @type {HTMLInputElement} */ (field).checked !== next) {\n        /** @type {HTMLInputElement} */ (field).checked = next\n            }\n            return\n        }\n\n        // For radio groups, set checked when the value matches this radio's value\n        if (isRadio) {\n            const radio = /** @type {HTMLInputElement} */ (field)\n            const shouldCheck = String(value ?? \"\") === radio.value\n            if (radio.checked !== shouldCheck) radio.checked = shouldCheck\n            return\n        }\n\n        const next = value ?? \"\"\n        if (field.value !== String(next)) field.value = String(next)\n    })\n\n    disposers.push(dispose)\n}\n\ndirective(bindXModel)", "import { directive } from \"../core/directives.js\"\nimport { devAssert, devWarn, elementTag, isPathSafe, unwrap } from \"../core/utils.js\"\n\n/**\n * Bind `x-bind:*` attribute directives.\n *\n * Examples:\n *   <input x-bind:placeholder=\"placeholder\">\n *   <button x-bind:disabled=\"isBusy\">Save</button>\n *   <a x-bind:href=\"profileUrl\">Profile</a>\n *\n * Rules:\n * - expression must be a safe dot-path (no eval)\n * - unwrap() is applied so you can pass signals or plain values\n *\n * @param {import(\"../core/runtime.js\").DirectiveContext} ctx\n */\nexport function bindXBind(ctx) {\n    const { el, scope, getPath, effect, disposers } = ctx\n\n    // gather all x-bind:* on this element\n    for (const attr of el.attributes) {\n        if (!attr.name.startsWith(\"x-bind:\")) continue\n        const arg = attr.name.slice(\"x-bind:\".length).trim()\n        const expr = (attr.value ?? \"\").trim()\n        if (!arg) {\n            devWarn(`[sting] x-bind missing attribute name`, el)\n            continue\n        }\n        if (!expr) {\n            devWarn(`[sting] x-bind:${arg} is missing an expression`, el)\n            continue\n        }\n\n        devAssert(isPathSafe(expr), `[sting] x-bind:${arg} invalid path \"${expr}\"`)\n\n        const dispose = effect(() => {\n            const resolved = getPath(scope, expr)\n            const value = unwrap(resolved)\n            applyBinding(el, arg, value)\n        })\n\n        disposers.push(dispose)\n    }\n\n}\n\ndirective(bindXBind)\n\n/**\n * Apply a binding to an element attribute/property.\n *\n * @param {Element} el\n * @param {string} attr\n * @param {any} value\n */\nfunction applyBinding(el, attr, value) {\n    const tag = elementTag(el)\n\n    // --- boolean-ish attributes ---\n    if (\n        attr === \"disabled\" ||\n        attr === \"checked\" ||\n        attr === \"selected\" ||\n        attr === \"readonly\" ||\n        attr === \"required\"\n    ) {\n        const next = !!value\n\n        // DOM property names:\n        const prop =\n            attr === \"readonly\" ? \"readOnly\" : attr\n\n        // @ts-ignore\n        if (prop in el) el[prop] = next\n\n        if (next) el.setAttribute(attr, \"\")\n        else el.removeAttribute(attr)\n\n        return\n    }\n\n    // --- value prop (inputs) ---\n    if (attr === \"value\" && (tag === \"input\" || tag === \"textarea\" || tag === \"select\")) {\n        const next = value ?? \"\"\n        // @ts-ignore\n        if (el.value !== String(next)) el.value = String(next)\n        return\n    }\n\n    if (attr === \"class\") {\n        applyClassBinding(el, value)\n        return\n    }\n\n    // --- style (string or object) ---\n    if (attr === \"style\") {\n        if (value && typeof value === \"object\") {\n            const parts = []\n            for (const [k, v] of Object.entries(value)) {\n                if (v == null || v === false) continue\n                parts.push(`${k}: ${String(v)};`)\n            }\n            el.setAttribute(\"style\", parts.join(\" \"))\n        } else {\n            el.setAttribute(\"style\", value ?? \"\")\n        }\n        return\n    }\n\n    // --- default: attribute ---\n    if (value == null || value === false) {\n        el.removeAttribute(attr)\n    } else {\n        el.setAttribute(attr, String(value))\n    }\n}\n\nconst CLASS_STATE = new WeakMap()\n\nfunction initClassState(el) {\n    let st = CLASS_STATE.get(el)\n    if (st) return st\n    st = {\n        base: new Set((el.getAttribute(\"class\") || \"\").split(/\\s+/).filter(Boolean)),\n        applied: new Set(),\n    }\n    CLASS_STATE.set(el, st)\n    return st\n}\n\nfunction normalizeClassValue(value) {\n    // supports: \"a b\", [\"a\",\"b\"], {a:true,b:false}\n    const out = new Set()\n\n    if (!value) return out\n\n    if (typeof value === \"string\") {\n        value.split(/\\s+/).filter(Boolean).forEach(c => out.add(c))\n        return out\n    }\n\n    if (Array.isArray(value)) {\n        for (const item of value) {\n            if (typeof item === \"string\") item.split(/\\s+/).filter(Boolean).forEach(c => out.add(c))\n        }\n        return out\n    }\n\n    if (typeof value === \"object\") {\n        for (const [cls, on] of Object.entries(value)) {\n            if (on) cls.split(/\\s+/).filter(Boolean).forEach(c => out.add(c))\n        }\n        return out\n    }\n\n    return out\n}\n\nfunction applyClassBinding(el, value) {\n    const st = initClassState(el)\n    const next = normalizeClassValue(value)\n\n    // remove previously applied bound classes\n    for (const c of st.applied) {\n        el.classList.remove(c)\n    }\n\n    // ensure base classes are present (in case something removed them)\n    for (const c of st.base) {\n        el.classList.add(c)\n    }\n\n    // add new bound classes\n    for (const c of next) {\n        el.classList.add(c)\n    }\n\n    st.applied = next\n}\n", "import { makeSting } from \"./shared.js\"\n\n// built-in directives (self-register via directive(...))\nimport \"../directives/x-text.js\"\nimport \"../directives/x-show.js\"\nimport \"../directives/x-on.js\"\nimport \"../directives/x-debug.js\"\nimport \"../directives/x-model.js\"\nimport \"../directives/x-bind.js\"\n\nconst sting = makeSting()\n\n// auto-start on DOM ready (safety net)\nsting.autoStart()\n\nexport default sting\n\nexport const {\n  data,\n  start,\n  autoStart,\n  signal,\n  effect,\n  batch,\n  untrack,\n  computed,\n  store,\n  produce,\n  directive,\n  use,\n  binders,\n} = sting\n"],
  "mappings": "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",
  "names": ["signal", "autoStart", "data", "getAttr", "getPath", "effect", "getAttr", "getPath", "effect", "getPath", "getAttr", "getPath", "effect", "untrack", "getAttr", "getPath", "setPath", "effect", "next", "getPath", "effect", "data", "start", "signal", "effect", "batch", "untrack", "computed", "store", "produce", "directive", "use", "binders"]
}
